{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PySideX PySide eXtras is a collection of extra resources for pyside with a focus on CSD ( Client-side decoration ). It is the basis of the ( MPX ) project. Conforms to the list of objectives specified in the \" Client-Side Decorations Initiative \" of the Gnome project. QApplicationWindow : A CSD (Client-side decoration) window without server-side decoration (SSD). It is resizable in all corners and has a shadow (optional). QControlButton : A Window control button. It could be the \"close\", \"minimize\" or \"maximize\" button. QWindowControlButtons : The buttons to \"close\", \"maximize\" and \"minimize\" the window. QWindowMoveArea : An area to drag the window. It is also possible to maximize and demaximize the window by double-clicking. QHeaderBar : A ready-made header bar, with drag area (QWindowMoveArea), control buttons (QWindowControlButtons), the window icon and methods for adding widgets to its right and left. When possible, the control buttons respect the positioning settings, the global menu and the system theme. They also behave desirably when the window is full screen. *The theme is still the PySide default","title":"PySideX"},{"location":"#pysidex","text":"PySide eXtras is a collection of extra resources for pyside with a focus on CSD ( Client-side decoration ). It is the basis of the ( MPX ) project. Conforms to the list of objectives specified in the \" Client-Side Decorations Initiative \" of the Gnome project. QApplicationWindow : A CSD (Client-side decoration) window without server-side decoration (SSD). It is resizable in all corners and has a shadow (optional). QControlButton : A Window control button. It could be the \"close\", \"minimize\" or \"maximize\" button. QWindowControlButtons : The buttons to \"close\", \"maximize\" and \"minimize\" the window. QWindowMoveArea : An area to drag the window. It is also possible to maximize and demaximize the window by double-clicking. QHeaderBar : A ready-made header bar, with drag area (QWindowMoveArea), control buttons (QWindowControlButtons), the window icon and methods for adding widgets to its right and left. When possible, the control buttons respect the positioning settings, the global menu and the system theme. They also behave desirably when the window is full screen. *The theme is still the PySide default","title":"PySideX"},{"location":"about/","text":"About Sources: https://github.com/reticulardev/pysidex","title":"About"},{"location":"about/#about","text":"Sources: https://github.com/reticulardev/pysidex","title":"About"},{"location":"overview/","text":"Overview This is a work that uses Qt's Python bind to build a window with its own decoration ( CSD ), which eliminates the decoration of the operating system's window server ( SSD ). Qt is an old and mature lib, but it was not originally designed to provide CSD support. Although it has added initial native support to CSD in recent years, it is still an incomplete work. Therefore, the PySideX and MPX projects are CSD implementations usable within the limits of Qt. So some hacks were made so that it was possible to have a usable window with desirable features such as a headerbar, customization of window borders, window control buttons with native platform integration, window resizing and movement. Targets There are necessary and some desirable goals to be met, and as a parameter, we use the \" Client-Side Decorations Initiative \" of the Gnome project as a necessary goal to be met. This initiative contains a list of reasonable goals to achieve: No title bar Native-looking close/maximize/minimize icons Respect the setting for showing/hiding minimize and maximize Respect the setting for buttons to be on the left/right side of the window Provide native system context menu on right click Limitations and mitigations Desirable goals to be achieved are part of some limitations. Some of the Qt Company's difficulties in supporting CSD were addressed in article \" Custom client-side window decorations in Qt 5.15 \" on group blog. One of the details that has not yet been resolved is maintaining the window shadow when using the 'FramelessWindowHint' flag, which removes the server-side decorations. We could request 1 edge pixel from the window server, but this would prevent us from customizing the corners in a satisfactory way. When remembering that customizing the edges is the biggest gain in CSD, messing it up would destroy the most significant part of the project. Therefore, we chose to provide a non-native shadow using Qt effects, which can be easily manipulated or removed, and also easy to change when an update to this feature becomes available. Another particularity to be resolved is the menu bar. As it is not rendered properly in the translucent part of the QMainWindow, which is modified to adapt the borders, it loses integration with global menus. The interesting thing here is that the CSD was designed for \"UX/UI design\" which does not match menu bars, as many have already observed. The reason for this, is because they are very large and disorganized. In modern programs they are already disabled, or sometimes with access shortcut. An alternative UX design approach is recommended in this case. Another inconvenience is windows with a blurred background. It's not impossible or very complicated to blur the background of the QMainWindow, but we had some pertinent problems with the window mask. It is not always able to remove the effect outside the rounded edges, leaving those little points slightly visible. Believe me, even those who don't have \"OCD\" start to acquire it after looking at it for a while. Therefore, as providing windows with blurred backgrounds by default is not a priority, this has temporarily fallen out of the plans. Maintainability The extra widgets are designed to be limited to the minimum possible, just to provide a CSD Window. This means that all graphics library support officially remains with the Qt Company. This decision makes the project small and gives us the chance to keep it actively updated with the latest stable versions of Pyside. It also provides the security of being able to continue officially using the robust original Qt. Code style Qt originally uses the camelCase code style and this is reflected in PySide which also uses it by default. In an effort to make Python code idiomatic, the snake_case and true_property feature were introduced. Find out more about the feature in the official Pyside documentation It really makes you want to tear your eyes out when you see a method written in camelCase . That's why we decided to use the snake_case feature so that the code would be more beautiful and easier to read in a Pythonic style, as it should be! from __feature__ import snake_case The true_property feature is different. There is a lot of Python code that uses conventional getters and setters methods, as in the case of the GTK bind to Python, PyGObject, making it clear that this is not a widespread desire. Also, Qt doesn't make it very easy to distinguish by name whether the method is a function or a property. There are many methods that start with the word \"set\" that are not for accessing a property, and this causes a bit of confusion. Since Python was designed to be simple with the goal of writing code faster, and true_property is not generally used or very intuitive in Qt, we chose not to use this feature. So consider all properties as hidden and access any information through getters and setters methods. Anyone who has worked with PyGObject, the GTK bind to Python, will feel right at home. *This is a project based on QtWidgets and for now there are no plans to support QML. Conclusion As Qt Company progresses with CSD support, this project will be improved. And fortunately, it is now possible to obtain a usable and satisfactory result. The Widgets that were created are very flexible and easy to implement.","title":"Overview"},{"location":"overview/#overview","text":"This is a work that uses Qt's Python bind to build a window with its own decoration ( CSD ), which eliminates the decoration of the operating system's window server ( SSD ). Qt is an old and mature lib, but it was not originally designed to provide CSD support. Although it has added initial native support to CSD in recent years, it is still an incomplete work. Therefore, the PySideX and MPX projects are CSD implementations usable within the limits of Qt. So some hacks were made so that it was possible to have a usable window with desirable features such as a headerbar, customization of window borders, window control buttons with native platform integration, window resizing and movement.","title":"Overview"},{"location":"overview/#targets","text":"There are necessary and some desirable goals to be met, and as a parameter, we use the \" Client-Side Decorations Initiative \" of the Gnome project as a necessary goal to be met. This initiative contains a list of reasonable goals to achieve: No title bar Native-looking close/maximize/minimize icons Respect the setting for showing/hiding minimize and maximize Respect the setting for buttons to be on the left/right side of the window Provide native system context menu on right click","title":"Targets"},{"location":"overview/#limitations-and-mitigations","text":"Desirable goals to be achieved are part of some limitations. Some of the Qt Company's difficulties in supporting CSD were addressed in article \" Custom client-side window decorations in Qt 5.15 \" on group blog. One of the details that has not yet been resolved is maintaining the window shadow when using the 'FramelessWindowHint' flag, which removes the server-side decorations. We could request 1 edge pixel from the window server, but this would prevent us from customizing the corners in a satisfactory way. When remembering that customizing the edges is the biggest gain in CSD, messing it up would destroy the most significant part of the project. Therefore, we chose to provide a non-native shadow using Qt effects, which can be easily manipulated or removed, and also easy to change when an update to this feature becomes available. Another particularity to be resolved is the menu bar. As it is not rendered properly in the translucent part of the QMainWindow, which is modified to adapt the borders, it loses integration with global menus. The interesting thing here is that the CSD was designed for \"UX/UI design\" which does not match menu bars, as many have already observed. The reason for this, is because they are very large and disorganized. In modern programs they are already disabled, or sometimes with access shortcut. An alternative UX design approach is recommended in this case. Another inconvenience is windows with a blurred background. It's not impossible or very complicated to blur the background of the QMainWindow, but we had some pertinent problems with the window mask. It is not always able to remove the effect outside the rounded edges, leaving those little points slightly visible. Believe me, even those who don't have \"OCD\" start to acquire it after looking at it for a while. Therefore, as providing windows with blurred backgrounds by default is not a priority, this has temporarily fallen out of the plans.","title":"Limitations and mitigations"},{"location":"overview/#maintainability","text":"The extra widgets are designed to be limited to the minimum possible, just to provide a CSD Window. This means that all graphics library support officially remains with the Qt Company. This decision makes the project small and gives us the chance to keep it actively updated with the latest stable versions of Pyside. It also provides the security of being able to continue officially using the robust original Qt.","title":"Maintainability"},{"location":"overview/#code-style","text":"Qt originally uses the camelCase code style and this is reflected in PySide which also uses it by default. In an effort to make Python code idiomatic, the snake_case and true_property feature were introduced. Find out more about the feature in the official Pyside documentation It really makes you want to tear your eyes out when you see a method written in camelCase . That's why we decided to use the snake_case feature so that the code would be more beautiful and easier to read in a Pythonic style, as it should be! from __feature__ import snake_case The true_property feature is different. There is a lot of Python code that uses conventional getters and setters methods, as in the case of the GTK bind to Python, PyGObject, making it clear that this is not a widespread desire. Also, Qt doesn't make it very easy to distinguish by name whether the method is a function or a property. There are many methods that start with the word \"set\" that are not for accessing a property, and this causes a bit of confusion. Since Python was designed to be simple with the goal of writing code faster, and true_property is not generally used or very intuitive in Qt, we chose not to use this feature. So consider all properties as hidden and access any information through getters and setters methods. Anyone who has worked with PyGObject, the GTK bind to Python, will feel right at home. *This is a project based on QtWidgets and for now there are no plans to support QML.","title":"Code style"},{"location":"overview/#conclusion","text":"As Qt Company progresses with CSD support, this project will be improved. And fortunately, it is now possible to obtain a usable and satisfactory result. The Widgets that were created are very flexible and easy to implement.","title":"Conclusion"},{"location":"quick_start/","text":"Quick start We will start by downloading the project and configuring the environment. Download and configure Download and enter the project directory: git clone https://github.com/reticulardev/pysidex.git && cd pysidex/ Configure your virtual environment: python3 -m venv venv && . venv/bin/activate Update pip and install dependencies: python -m pip install --upgrade pip && python -m pip install -r requirements.txt Run the example to see it working: python src/demo.py The imports In your code file, import the sys lib, import PySide to have access to all widgets, import PySideX to build the CSD window and finally configure the snake_case feature. As already mentioned, the project uses the snake_case feature to obtain idiomatic code. import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case The minimal example A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: A more complete minimal example In this example, we will add the 'os' library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Quick start"},{"location":"quick_start/#quick-start","text":"We will start by downloading the project and configuring the environment.","title":"Quick start"},{"location":"quick_start/#download-and-configure","text":"Download and enter the project directory: git clone https://github.com/reticulardev/pysidex.git && cd pysidex/ Configure your virtual environment: python3 -m venv venv && . venv/bin/activate Update pip and install dependencies: python -m pip install --upgrade pip && python -m pip install -r requirements.txt Run the example to see it working: python src/demo.py","title":"Download and configure"},{"location":"quick_start/#the-imports","text":"In your code file, import the sys lib, import PySide to have access to all widgets, import PySideX to build the CSD window and finally configure the snake_case feature. As already mentioned, the project uses the snake_case feature to obtain idiomatic code. import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case","title":"The imports"},{"location":"quick_start/#the-minimal-example","text":"A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result:","title":"The minimal example"},{"location":"quick_start/#a-more-complete-minimal-example","text":"In this example, we will add the 'os' library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"A more complete minimal example"},{"location":"reference_PlatformSettings/","text":"PlatformSettings User platform settings information. Overview It is a utility that provides information about the user's platform that is relevant for customizing the application Window. This is information about the theme, operating system, order of the window control buttons, border shape and things like that. Class signature PlatformSettings(platform_integration: bool = True) Parameters platform_integration : Type bool . Default is True Using False will not bring platform information, it will bring library defaults. Using True will obtain platform information, only when possible and if it is supported. Properties desktop_environment operational_system desktop_environment Signature: desktop_environment() -> DesktopEnvironment[Enum] So far supports KDE, GNOME, CINNAMON, XFCE and UNKNOWN DesktopEnvironment = Enum( 'DesktopEnvironment', ['UNKNOWN', 'KDE', 'GNOME', 'CINNAMON', 'XFCE']) operational_system Signature: operational_system() -> OperationalSystem[Enum] So far supports LINUX, BSD, MAC, WINDOWS and UNKNOWN OperationalSystem = Enum( 'OperationalSystem', ['UNKNOWN', 'LINUX', 'BSD', 'MAC', 'WINDOWS']) Methods window_control_button_style window_control_button_order window_border_radius window_use_global_menu window_control_button_style Signature: window_control_button_style(window_is_dark: bool, button_name: str, button_state: str) -> str | None Parameter window_is_dark : bool , Inform if the Window is dark Parameter button_name : str , Inform if is 'minimize', 'maximize', 'restore' or 'close' Parameter button_state : str , Inform if is 'normal', 'hover', 'inactive' Returns a str with the button's QSS style or None window_control_button_order Signature: window_control_button_order() -> tuple | None A int tuple with the order of the buttons: (0, 1, 2) window_border_radius Signature: window_border_radius() -> tuple | None A int tuple with the radius of the 4 corners of the window: (5, 5, 5, 5) window_use_global_menu Signature: window_use_global_menu() -> bool True if the platform is using a global menu, otherwise returns False","title":"PlatformSettings"},{"location":"reference_PlatformSettings/#platformsettings","text":"User platform settings information.","title":"PlatformSettings"},{"location":"reference_PlatformSettings/#overview","text":"It is a utility that provides information about the user's platform that is relevant for customizing the application Window. This is information about the theme, operating system, order of the window control buttons, border shape and things like that.","title":"Overview"},{"location":"reference_PlatformSettings/#class-signature","text":"PlatformSettings(platform_integration: bool = True)","title":"Class signature"},{"location":"reference_PlatformSettings/#parameters","text":"platform_integration : Type bool . Default is True Using False will not bring platform information, it will bring library defaults. Using True will obtain platform information, only when possible and if it is supported.","title":"Parameters"},{"location":"reference_PlatformSettings/#properties","text":"desktop_environment operational_system","title":"Properties"},{"location":"reference_PlatformSettings/#desktop_environment","text":"Signature: desktop_environment() -> DesktopEnvironment[Enum] So far supports KDE, GNOME, CINNAMON, XFCE and UNKNOWN DesktopEnvironment = Enum( 'DesktopEnvironment', ['UNKNOWN', 'KDE', 'GNOME', 'CINNAMON', 'XFCE'])","title":"desktop_environment"},{"location":"reference_PlatformSettings/#operational_system","text":"Signature: operational_system() -> OperationalSystem[Enum] So far supports LINUX, BSD, MAC, WINDOWS and UNKNOWN OperationalSystem = Enum( 'OperationalSystem', ['UNKNOWN', 'LINUX', 'BSD', 'MAC', 'WINDOWS'])","title":"operational_system"},{"location":"reference_PlatformSettings/#methods","text":"window_control_button_style window_control_button_order window_border_radius window_use_global_menu","title":"Methods"},{"location":"reference_PlatformSettings/#window_control_button_style","text":"Signature: window_control_button_style(window_is_dark: bool, button_name: str, button_state: str) -> str | None Parameter window_is_dark : bool , Inform if the Window is dark Parameter button_name : str , Inform if is 'minimize', 'maximize', 'restore' or 'close' Parameter button_state : str , Inform if is 'normal', 'hover', 'inactive' Returns a str with the button's QSS style or None","title":"window_control_button_style"},{"location":"reference_PlatformSettings/#window_control_button_order","text":"Signature: window_control_button_order() -> tuple | None A int tuple with the order of the buttons: (0, 1, 2)","title":"window_control_button_order"},{"location":"reference_PlatformSettings/#window_border_radius","text":"Signature: window_border_radius() -> tuple | None A int tuple with the radius of the 4 corners of the window: (5, 5, 5, 5)","title":"window_border_radius"},{"location":"reference_PlatformSettings/#window_use_global_menu","text":"Signature: window_use_global_menu() -> bool True if the platform is using a global menu, otherwise returns False","title":"window_use_global_menu"},{"location":"reference_QApplicationWindow/","text":"QApplicationWindow Inherits from QMainWindow Overview The main window of an application. It was built under QMainWindow and some modifications were made to achieve the CSD feature. Class signature QApplicationWindow(is_decorated: bool = False, platform: bool = True) Parameters is_decorated : Type bool , default is False Use False if it is an undecorated CSD window and True if it is server-side decorated. platform : Type bool , default is True The default is True , which is used to follow the user's platform style. These are the control button styles, color and shape of the window borders. Setting False will make the window use an alternative default style. Methods Only new ones. See the QMainWindow documentation for more. central_widget is_decorated platform_settings reset_style central_widget Signature: central_widget() -> QWidget A pre-configured QWidget . Is a central part of the QApplicationWindow . The main layout of your application must be added to it. self.layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.layout) is_decorated Signature: is_decorated() -> bool Returns False if it is an undecorated CSD window and True if it is server-side decorated. platform_settings Signature: platform_settings() -> PlatformSettings A PlatformSettings object that brings information from the user's platform that is relevant to the composition of the window. reset_style Signature: reset_style() -> None Changes the window style back to the default. Signals event_filter_signal = QtCore.Signal(object) resize_event_signal = QtCore.Signal(object) Changes A pre-configured central widget already exists and is a central part of the QApplicationWindow . You will get it for use through the central_widget method. The set_object_name method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name \"QApplicationWindow{...}\". The event_filter method has been rewritten, so use the event_filter_signal signal, or consider using event-specific methods such as enter_event and leave_vent . Examples A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: A more complete minimal example In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result: Using all concepts We created the following example to use all the practical concepts in this window, such as using specific event methods instead of event_filter , and also using the \"QApplicationWindow\" id for QSS style . #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"QApplicationWindow"},{"location":"reference_QApplicationWindow/#qapplicationwindow","text":"Inherits from QMainWindow","title":"QApplicationWindow"},{"location":"reference_QApplicationWindow/#overview","text":"The main window of an application. It was built under QMainWindow and some modifications were made to achieve the CSD feature.","title":"Overview"},{"location":"reference_QApplicationWindow/#class-signature","text":"QApplicationWindow(is_decorated: bool = False, platform: bool = True)","title":"Class signature"},{"location":"reference_QApplicationWindow/#parameters","text":"is_decorated : Type bool , default is False Use False if it is an undecorated CSD window and True if it is server-side decorated. platform : Type bool , default is True The default is True , which is used to follow the user's platform style. These are the control button styles, color and shape of the window borders. Setting False will make the window use an alternative default style.","title":"Parameters"},{"location":"reference_QApplicationWindow/#methods","text":"Only new ones. See the QMainWindow documentation for more. central_widget is_decorated platform_settings reset_style","title":"Methods"},{"location":"reference_QApplicationWindow/#central_widget","text":"Signature: central_widget() -> QWidget A pre-configured QWidget . Is a central part of the QApplicationWindow . The main layout of your application must be added to it. self.layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.layout)","title":"central_widget"},{"location":"reference_QApplicationWindow/#is_decorated","text":"Signature: is_decorated() -> bool Returns False if it is an undecorated CSD window and True if it is server-side decorated.","title":"is_decorated"},{"location":"reference_QApplicationWindow/#platform_settings","text":"Signature: platform_settings() -> PlatformSettings A PlatformSettings object that brings information from the user's platform that is relevant to the composition of the window.","title":"platform_settings"},{"location":"reference_QApplicationWindow/#reset_style","text":"Signature: reset_style() -> None Changes the window style back to the default.","title":"reset_style"},{"location":"reference_QApplicationWindow/#signals","text":"event_filter_signal = QtCore.Signal(object) resize_event_signal = QtCore.Signal(object)","title":"Signals"},{"location":"reference_QApplicationWindow/#changes","text":"A pre-configured central widget already exists and is a central part of the QApplicationWindow . You will get it for use through the central_widget method. The set_object_name method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name \"QApplicationWindow{...}\". The event_filter method has been rewritten, so use the event_filter_signal signal, or consider using event-specific methods such as enter_event and leave_vent .","title":"Changes"},{"location":"reference_QApplicationWindow/#examples","text":"A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result:","title":"Examples"},{"location":"reference_QApplicationWindow/#a-more-complete-minimal-example","text":"In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"A more complete minimal example"},{"location":"reference_QApplicationWindow/#using-all-concepts","text":"We created the following example to use all the practical concepts in this window, such as using specific event methods instead of event_filter , and also using the \"QApplicationWindow\" id for QSS style . #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Using all concepts"},{"location":"reference_QControlButton/","text":"QControlButton Inherits from QToolButton Overview A window control button. It could be the close, maximize or minimize button. Class signature QControlButton( main_window: QApplicationWindow[QtWidgets, QMainWindow], button_id: int) Parameters main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.control_button = QControlButton(self, 2) button_id : Type int It can be the number 0, 1, 2 or 3. Each number represents a type of button: 0 is the minimize button, 1 is the maximize button, 2 is the close button and 3 is window icon . Signals enter_event_signal = QtCore.Signal(object) leave_event_signal = QtCore.Signal(object) Changes Methods enter_event and leave_vent have been rewritten, so use the enter_event_signal and leave_event_signal signals, or consider using event-specific methods such as event_filter . Example self.control_button = QControlButton(self, 2) self.layout.add_widget(self.control_button)","title":"QControlButton"},{"location":"reference_QControlButton/#qcontrolbutton","text":"Inherits from QToolButton","title":"QControlButton"},{"location":"reference_QControlButton/#overview","text":"A window control button. It could be the close, maximize or minimize button.","title":"Overview"},{"location":"reference_QControlButton/#class-signature","text":"QControlButton( main_window: QApplicationWindow[QtWidgets, QMainWindow], button_id: int)","title":"Class signature"},{"location":"reference_QControlButton/#parameters","text":"main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.control_button = QControlButton(self, 2) button_id : Type int It can be the number 0, 1, 2 or 3. Each number represents a type of button: 0 is the minimize button, 1 is the maximize button, 2 is the close button and 3 is window icon .","title":"Parameters"},{"location":"reference_QControlButton/#signals","text":"enter_event_signal = QtCore.Signal(object) leave_event_signal = QtCore.Signal(object)","title":"Signals"},{"location":"reference_QControlButton/#changes","text":"Methods enter_event and leave_vent have been rewritten, so use the enter_event_signal and leave_event_signal signals, or consider using event-specific methods such as event_filter .","title":"Changes"},{"location":"reference_QControlButton/#example","text":"self.control_button = QControlButton(self, 2) self.layout.add_widget(self.control_button)","title":"Example"},{"location":"reference_QHeaderBar/","text":"QHeaderBar Inherits from QFrame Overview The main control area of an application window, where there are close, maximize and minimize buttons, along with a movement area and the application icon. It's a regular widget and can be aligned wherever you want, not just at the top of the window, but also in other places like the middle or bottom if you're a psychopath. Class signature QHeaderBar(main_window: QApplicationWindow[QtWidgets, QMainWindow]) Parameters main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.headerbar = QHeaderBar(self) Methods Only new ones. See the QFrame documentation for more. add_widget_to_left add_widget_to_right control_buttons_side lef_layout right_layout set_left_control_buttons_visible set_move_area_as_enable set_right_control_buttons_visible set_text set_window_icon text add_widget_to_left Signature: add_widget_to_left(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the left side of the header bar (after the control buttons or window icon). add_widget_to_right Signature: add_widget_to_right(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the right side of the header bar (before the control buttons or window icon). control_buttons_side Signature: control_buttons_side(self) -> str Window control buttons side. Return 'left' or 'right' string. lef_layout Signature: lef_layout() -> QHBoxLayout Gets the left layout of the header bar. It is the layout where widgets are added when using the add_widget_to_left method. right_layout Signature: right_layout() -> QHBoxLayout Gets the right layout of the header bar. It is the layout where widgets are added when using the add_widget_to_right method. set_left_control_buttons_visible Signature: set_left_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the left side of the window. Setting this to False will hide them, and True will show them. set_move_area_as_enable Signature: set_move_area_as_enable(enable: bool) -> None Parameter enable : bool Enable or disable the window moving area. The area does not disappear, it just does not respond to clicking and dragging the mouse cursor. set_right_control_buttons_visible Signature: set_right_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the right side of the window. Setting this to False will hide them, and True will show them. set_text Signature: set_text(text: str) -> None Parameter text : str Add text in the middle of the header bar. This is typically the text used as the window title. set_window_icon Signature: set_window_icon(icon: QIcon) -> None Parameter icon : QtGui.QIcon A new icon to update the application icon text Signature: text() -> str Gets the text of the header bar. This is the text in the middle, normally used as the window title. Signals resize_event_signal = QtCore.Signal(object) Changes The resize_event method has been rewritten, so use the resize_event_signal signal, or consider using event-specific methods such as event_filter . Examples Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) A more complete minimal example In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. SRC_DIR = os.path.dirname(os.path.abspath(__file__)) ... icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. self.set_window_title('App title') self.headerbar.set_text(self.window_title()) We also added a search button on the left side and a menu button on the right side of the header bar # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) This is the result: # !/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) # Window size self.set_minimum_width(300) self.set_minimum_height(200) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec())","title":"QHeaderBar"},{"location":"reference_QHeaderBar/#qheaderbar","text":"Inherits from QFrame","title":"QHeaderBar"},{"location":"reference_QHeaderBar/#overview","text":"The main control area of an application window, where there are close, maximize and minimize buttons, along with a movement area and the application icon. It's a regular widget and can be aligned wherever you want, not just at the top of the window, but also in other places like the middle or bottom if you're a psychopath.","title":"Overview"},{"location":"reference_QHeaderBar/#class-signature","text":"QHeaderBar(main_window: QApplicationWindow[QtWidgets, QMainWindow])","title":"Class signature"},{"location":"reference_QHeaderBar/#parameters","text":"main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.headerbar = QHeaderBar(self)","title":"Parameters"},{"location":"reference_QHeaderBar/#methods","text":"Only new ones. See the QFrame documentation for more. add_widget_to_left add_widget_to_right control_buttons_side lef_layout right_layout set_left_control_buttons_visible set_move_area_as_enable set_right_control_buttons_visible set_text set_window_icon text","title":"Methods"},{"location":"reference_QHeaderBar/#add_widget_to_left","text":"Signature: add_widget_to_left(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the left side of the header bar (after the control buttons or window icon).","title":"add_widget_to_left"},{"location":"reference_QHeaderBar/#add_widget_to_right","text":"Signature: add_widget_to_right(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the right side of the header bar (before the control buttons or window icon).","title":"add_widget_to_right"},{"location":"reference_QHeaderBar/#control_buttons_side","text":"Signature: control_buttons_side(self) -> str Window control buttons side. Return 'left' or 'right' string.","title":"control_buttons_side"},{"location":"reference_QHeaderBar/#lef_layout","text":"Signature: lef_layout() -> QHBoxLayout Gets the left layout of the header bar. It is the layout where widgets are added when using the add_widget_to_left method.","title":"lef_layout"},{"location":"reference_QHeaderBar/#right_layout","text":"Signature: right_layout() -> QHBoxLayout Gets the right layout of the header bar. It is the layout where widgets are added when using the add_widget_to_right method.","title":"right_layout"},{"location":"reference_QHeaderBar/#set_left_control_buttons_visible","text":"Signature: set_left_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the left side of the window. Setting this to False will hide them, and True will show them.","title":"set_left_control_buttons_visible"},{"location":"reference_QHeaderBar/#set_move_area_as_enable","text":"Signature: set_move_area_as_enable(enable: bool) -> None Parameter enable : bool Enable or disable the window moving area. The area does not disappear, it just does not respond to clicking and dragging the mouse cursor.","title":"set_move_area_as_enable"},{"location":"reference_QHeaderBar/#set_right_control_buttons_visible","text":"Signature: set_right_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the right side of the window. Setting this to False will hide them, and True will show them.","title":"set_right_control_buttons_visible"},{"location":"reference_QHeaderBar/#set_text","text":"Signature: set_text(text: str) -> None Parameter text : str Add text in the middle of the header bar. This is typically the text used as the window title.","title":"set_text"},{"location":"reference_QHeaderBar/#set_window_icon","text":"Signature: set_window_icon(icon: QIcon) -> None Parameter icon : QtGui.QIcon A new icon to update the application icon","title":"set_window_icon"},{"location":"reference_QHeaderBar/#text","text":"Signature: text() -> str Gets the text of the header bar. This is the text in the middle, normally used as the window title.","title":"text"},{"location":"reference_QHeaderBar/#signals","text":"resize_event_signal = QtCore.Signal(object)","title":"Signals"},{"location":"reference_QHeaderBar/#changes","text":"The resize_event method has been rewritten, so use the resize_event_signal signal, or consider using event-specific methods such as event_filter .","title":"Changes"},{"location":"reference_QHeaderBar/#examples","text":"Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec())","title":"Examples"},{"location":"reference_QHeaderBar/#a-more-complete-minimal-example","text":"In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. SRC_DIR = os.path.dirname(os.path.abspath(__file__)) ... icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. self.set_window_title('App title') self.headerbar.set_text(self.window_title()) We also added a search button on the left side and a menu button on the right side of the header bar # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) This is the result: # !/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) # Window size self.set_minimum_width(300) self.set_minimum_height(200) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec())","title":"A more complete minimal example"},{"location":"reference_QWindowControlButtons/","text":"QWindowControlButtons Inherits from QFrame Overview Widget with window control buttons, to close, maximize and minimize. Class signature QWindowControlButtons( main_window: QApplicationWindow[QtWidgets, QMainWindow], button_order: tuple = (0, 1, 2)) Parameters main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.control_buttons = QWindowControlButtons(self, (0, 1, 2)) button_order : Type tuple . Default is (0, 1, 2) In the button order parameter, each number represents a type of button: 0 is the minimize button, 1 is the maximize button, 2 is the close button and 3 is window icon . Methods Only new ones. See the QFrame documentation for more. button_order update_window_icon button_order Signature: button_order() -> tuple Tuple with the order of the buttons. 0 is the minimize button, 1 is the maximize button, 2 is the close button and 3 is window icon . Like: (0, 1, 2,) update_window_icon Signature: update_window_icon(icon: QIcon) -> None Parameter icon : QtGui.QIcon A new icon to update the application icon Example self.control_buttons = QWindowControlButtons(self, (0, 1, 2)) self.layout.add_widget(self.control_buttons)","title":"QWindowControlButtons"},{"location":"reference_QWindowControlButtons/#qwindowcontrolbuttons","text":"Inherits from QFrame","title":"QWindowControlButtons"},{"location":"reference_QWindowControlButtons/#overview","text":"Widget with window control buttons, to close, maximize and minimize.","title":"Overview"},{"location":"reference_QWindowControlButtons/#class-signature","text":"QWindowControlButtons( main_window: QApplicationWindow[QtWidgets, QMainWindow], button_order: tuple = (0, 1, 2))","title":"Class signature"},{"location":"reference_QWindowControlButtons/#parameters","text":"main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.control_buttons = QWindowControlButtons(self, (0, 1, 2)) button_order : Type tuple . Default is (0, 1, 2) In the button order parameter, each number represents a type of button: 0 is the minimize button, 1 is the maximize button, 2 is the close button and 3 is window icon .","title":"Parameters"},{"location":"reference_QWindowControlButtons/#methods","text":"Only new ones. See the QFrame documentation for more. button_order update_window_icon","title":"Methods"},{"location":"reference_QWindowControlButtons/#button_order","text":"Signature: button_order() -> tuple Tuple with the order of the buttons. 0 is the minimize button, 1 is the maximize button, 2 is the close button and 3 is window icon . Like: (0, 1, 2,)","title":"button_order"},{"location":"reference_QWindowControlButtons/#update_window_icon","text":"Signature: update_window_icon(icon: QIcon) -> None Parameter icon : QtGui.QIcon A new icon to update the application icon","title":"update_window_icon"},{"location":"reference_QWindowControlButtons/#example","text":"self.control_buttons = QWindowControlButtons(self, (0, 1, 2)) self.layout.add_widget(self.control_buttons)","title":"Example"},{"location":"reference_QWindowMoveArea/","text":"QWindowMoveArea Inherits from QFrame Overview The area where you click and drag to move the window. Class signature QWindowMoveArea(main_window: QApplicationWindow[QtWidgets, QMainWindow]) Parameters main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.move_area = QHeaderBar(self) Methods Only new ones. See the QFrame documentation for more. set_enable set_enable Signature: set_enable(enable: bool) -> None Parameter enable : bool Enable or disable the window moving area. The area does not disappear, it just does not respond to clicking and dragging the mouse cursor. Signals mouse_press_event_signal = QtCore.Signal(object) mouse_double_click_event_signal = QtCore.Signal(object) Changes Methods mouse_press_event and mouse_double_click_event have been rewritten, so use the mouse_press_event_signal and mouse_double_click_event_signal signals, or consider using event-specific methods such as event_filter . Example self.move_area = QHeaderBar(self) self.layout.add_widget(self.move_area)","title":"QWindowMoveArea"},{"location":"reference_QWindowMoveArea/#qwindowmovearea","text":"Inherits from QFrame","title":"QWindowMoveArea"},{"location":"reference_QWindowMoveArea/#overview","text":"The area where you click and drag to move the window.","title":"Overview"},{"location":"reference_QWindowMoveArea/#class-signature","text":"QWindowMoveArea(main_window: QApplicationWindow[QtWidgets, QMainWindow])","title":"Class signature"},{"location":"reference_QWindowMoveArea/#parameters","text":"main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.move_area = QHeaderBar(self)","title":"Parameters"},{"location":"reference_QWindowMoveArea/#methods","text":"Only new ones. See the QFrame documentation for more. set_enable","title":"Methods"},{"location":"reference_QWindowMoveArea/#set_enable","text":"Signature: set_enable(enable: bool) -> None Parameter enable : bool Enable or disable the window moving area. The area does not disappear, it just does not respond to clicking and dragging the mouse cursor.","title":"set_enable"},{"location":"reference_QWindowMoveArea/#signals","text":"mouse_press_event_signal = QtCore.Signal(object) mouse_double_click_event_signal = QtCore.Signal(object)","title":"Signals"},{"location":"reference_QWindowMoveArea/#changes","text":"Methods mouse_press_event and mouse_double_click_event have been rewritten, so use the mouse_press_event_signal and mouse_double_click_event_signal signals, or consider using event-specific methods such as event_filter .","title":"Changes"},{"location":"reference_QWindowMoveArea/#example","text":"self.move_area = QHeaderBar(self) self.layout.add_widget(self.move_area)","title":"Example"},{"location":"styling/","text":"Styling The setObjectName method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name. self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') The remaining widgets remain unchanged. See the PySide documentation for more. Example #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Styling"},{"location":"styling/#styling","text":"The setObjectName method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name. self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') The remaining widgets remain unchanged. See the PySide documentation for more.","title":"Styling"},{"location":"styling/#example","text":"#!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Example"},{"location":"tests/","text":"Tests Download the Git repository and with the terminal enter the project directory. unittest Standard library unit tests can be run as follows python3 -m unittest discover coverage Test coverage can be verified using the \"coverage\" lib. Use pip to install it. pip3 install --upgrade pip pip3 install coverage Then run the unit tests using the \"coverage\" command and then use the \"report\" argument to get the test coverage status. coverage run -m unittest discover coverage report -m","title":"Tests"},{"location":"tests/#tests","text":"Download the Git repository and with the terminal enter the project directory.","title":"Tests"},{"location":"tests/#unittest","text":"Standard library unit tests can be run as follows python3 -m unittest discover","title":"unittest"},{"location":"tests/#coverage","text":"Test coverage can be verified using the \"coverage\" lib. Use pip to install it. pip3 install --upgrade pip pip3 install coverage Then run the unit tests using the \"coverage\" command and then use the \"report\" argument to get the test coverage status. coverage run -m unittest discover coverage report -m","title":"coverage"}]}