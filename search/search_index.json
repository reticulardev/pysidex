{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PySideX PySide eXtras is a collection of extra resources for pyside with a focus on CSD ( Client-side decoration ). It is the basis of the ( MPX ) project. Conforms to the list of objectives specified in the \" Client-Side Decorations Initiative \" of the Gnome project. QApplicationWindow : A CSD (Client-side decoration) window without server-side decoration (SSD). It is resizable in all corners and has a shadow (optional). QControlButton : A Window control button. It could be the \"close\", \"minimize\" or \"maximize\" button. QWindowControlButtons : The buttons to \"close\", \"maximize\" and \"minimize\" the window. QWindowMoveArea : An area to drag the window. It is also possible to maximize and demaximize the window by double-clicking. QHeaderBar : A ready-made header bar, with drag area (QWindowMoveArea), control buttons (QWindowControlButtons), the window icon and methods for adding widgets to its right and left. When possible, the control buttons respect the positioning settings, the global menu and the system theme. They also behave desirably when the window is full screen. *The theme is still the PySide default","title":"Introduction"},{"location":"#pysidex","text":"PySide eXtras is a collection of extra resources for pyside with a focus on CSD ( Client-side decoration ). It is the basis of the ( MPX ) project. Conforms to the list of objectives specified in the \" Client-Side Decorations Initiative \" of the Gnome project. QApplicationWindow : A CSD (Client-side decoration) window without server-side decoration (SSD). It is resizable in all corners and has a shadow (optional). QControlButton : A Window control button. It could be the \"close\", \"minimize\" or \"maximize\" button. QWindowControlButtons : The buttons to \"close\", \"maximize\" and \"minimize\" the window. QWindowMoveArea : An area to drag the window. It is also possible to maximize and demaximize the window by double-clicking. QHeaderBar : A ready-made header bar, with drag area (QWindowMoveArea), control buttons (QWindowControlButtons), the window icon and methods for adding widgets to its right and left. When possible, the control buttons respect the positioning settings, the global menu and the system theme. They also behave desirably when the window is full screen. *The theme is still the PySide default","title":"PySideX"},{"location":"about/","text":"About Sources: https://github.com/reticulardev/pysidex","title":"About"},{"location":"about/#about","text":"Sources: https://github.com/reticulardev/pysidex","title":"About"},{"location":"overview/","text":"Overview This is a work that uses Qt's Python bind to build a window with its own decoration ( CSD ), which eliminates the decoration of the operating system's window server ( SSD ). Qt is an old and mature lib, but it was not originally designed to provide CSD support. Although it has added initial native support to CSD in recent years, it is still an incomplete work. Therefore, the PySideX and MPX projects are CSD implementations usable within the limits of Qt. So some hacks were made so that it was possible to have a usable window with desirable features such as a headerbar, customization of window borders, window control buttons with native platform integration, window resizing and movement. Targets There are necessary and some desirable goals to be met, and as a parameter, we use the \" Client-Side Decorations Initiative \" of the Gnome project as a necessary goal to be met. This initiative contains a list of reasonable goals to achieve: No title bar Native-looking close/maximize/minimize icons Respect the setting for showing/hiding minimize and maximize Respect the setting for buttons to be on the left/right side of the window Provide native system context menu on right click Limitations and mitigations Desirable goals to be achieved are part of some limitations. Some of the Qt Company's difficulties in supporting CSD were addressed in article \" Custom client-side window decorations in Qt 5.15 \" on group blog. One of the details that has not yet been resolved is maintaining the window shadow when using the 'FramelessWindowHint' flag, which removes the server-side decorations. We could request 1 edge pixel from the window server, but this would prevent us from customizing the corners in a satisfactory way. When remembering that customizing the edges is the biggest gain in CSD, messing it up would destroy the most significant part of the project. Therefore, we chose to provide a non-native shadow using Qt effects, which can be easily manipulated or removed, and also easy to change when an update to this feature becomes available. Another particularity to be resolved is the menu bar. As it is not rendered properly in the translucent part of the QMainWindow, which is modified to adapt the borders, it loses integration with global menus. The interesting thing here is that the CSD was designed for \"UX/UI design\" which does not match menu bars, as many have already observed. The reason for this, is because they are very large and disorganized. In modern programs they are already disabled, or sometimes with access shortcut. An alternative UX design approach is recommended in this case. Another inconvenience is windows with a blurred background. It's not impossible or very complicated to blur the background of the QMainWindow, but we had some pertinent problems with the window mask. It is not always able to remove the effect outside the rounded edges, leaving those little points slightly visible. Believe me, even those who don't have \"OCD\" start to acquire it after looking at it for a while. Therefore, as providing windows with blurred backgrounds by default is not a priority, this has temporarily fallen out of the plans. Maintainability The extra widgets are designed to be limited to the minimum possible, just to provide a CSD Window. This means that all graphics library support officially remains with the Qt Company. This decision makes the project small and gives us the chance to keep it actively updated with the latest stable versions of Pyside. It also provides the security of being able to continue officially using the robust original Qt. Code style Qt originally uses the camelCase code style and this is reflected in PySide which also uses it by default. In an effort to make Python code idiomatic, the snake_case and true_property features were introduced. Find out more about the feature in the official Pyside documentation In our tests, the true_property feature didn't work well in every way, but the snake_case style was maintained. So consider all properties as hidden and access any information through getters and setters methods. Anyone who has worked with PyGObject, the GTK bind to Python, will feel right at home. This is a project based on QtWidgets and for now there are no plans to support QML. Conclusion As Qt Company progresses with CSD support, this project will be improved. And fortunately, it is now possible to obtain a usable and satisfactory result. The Widgets that were created are very flexible and easy to implement.","title":"Overview"},{"location":"overview/#overview","text":"This is a work that uses Qt's Python bind to build a window with its own decoration ( CSD ), which eliminates the decoration of the operating system's window server ( SSD ). Qt is an old and mature lib, but it was not originally designed to provide CSD support. Although it has added initial native support to CSD in recent years, it is still an incomplete work. Therefore, the PySideX and MPX projects are CSD implementations usable within the limits of Qt. So some hacks were made so that it was possible to have a usable window with desirable features such as a headerbar, customization of window borders, window control buttons with native platform integration, window resizing and movement.","title":"Overview"},{"location":"overview/#targets","text":"There are necessary and some desirable goals to be met, and as a parameter, we use the \" Client-Side Decorations Initiative \" of the Gnome project as a necessary goal to be met. This initiative contains a list of reasonable goals to achieve: No title bar Native-looking close/maximize/minimize icons Respect the setting for showing/hiding minimize and maximize Respect the setting for buttons to be on the left/right side of the window Provide native system context menu on right click","title":"Targets"},{"location":"overview/#limitations-and-mitigations","text":"Desirable goals to be achieved are part of some limitations. Some of the Qt Company's difficulties in supporting CSD were addressed in article \" Custom client-side window decorations in Qt 5.15 \" on group blog. One of the details that has not yet been resolved is maintaining the window shadow when using the 'FramelessWindowHint' flag, which removes the server-side decorations. We could request 1 edge pixel from the window server, but this would prevent us from customizing the corners in a satisfactory way. When remembering that customizing the edges is the biggest gain in CSD, messing it up would destroy the most significant part of the project. Therefore, we chose to provide a non-native shadow using Qt effects, which can be easily manipulated or removed, and also easy to change when an update to this feature becomes available. Another particularity to be resolved is the menu bar. As it is not rendered properly in the translucent part of the QMainWindow, which is modified to adapt the borders, it loses integration with global menus. The interesting thing here is that the CSD was designed for \"UX/UI design\" which does not match menu bars, as many have already observed. The reason for this, is because they are very large and disorganized. In modern programs they are already disabled, or sometimes with access shortcut. An alternative UX design approach is recommended in this case. Another inconvenience is windows with a blurred background. It's not impossible or very complicated to blur the background of the QMainWindow, but we had some pertinent problems with the window mask. It is not always able to remove the effect outside the rounded edges, leaving those little points slightly visible. Believe me, even those who don't have \"OCD\" start to acquire it after looking at it for a while. Therefore, as providing windows with blurred backgrounds by default is not a priority, this has temporarily fallen out of the plans.","title":"Limitations and mitigations"},{"location":"overview/#maintainability","text":"The extra widgets are designed to be limited to the minimum possible, just to provide a CSD Window. This means that all graphics library support officially remains with the Qt Company. This decision makes the project small and gives us the chance to keep it actively updated with the latest stable versions of Pyside. It also provides the security of being able to continue officially using the robust original Qt.","title":"Maintainability"},{"location":"overview/#code-style","text":"Qt originally uses the camelCase code style and this is reflected in PySide which also uses it by default. In an effort to make Python code idiomatic, the snake_case and true_property features were introduced. Find out more about the feature in the official Pyside documentation In our tests, the true_property feature didn't work well in every way, but the snake_case style was maintained. So consider all properties as hidden and access any information through getters and setters methods. Anyone who has worked with PyGObject, the GTK bind to Python, will feel right at home. This is a project based on QtWidgets and for now there are no plans to support QML.","title":"Code style"},{"location":"overview/#conclusion","text":"As Qt Company progresses with CSD support, this project will be improved. And fortunately, it is now possible to obtain a usable and satisfactory result. The Widgets that were created are very flexible and easy to implement.","title":"Conclusion"},{"location":"quick_start/","text":"Quick start We will start by downloading the project and configuring the environment. Download and configure Download and enter the project directory: git clone https://github.com/reticulardev/pysidex.git && cd pysidex/ Configure your virtual environment: python3 -m venv venv && . venv/bin/activate Update pip and install dependencies: python -m pip install --upgrade pip && python -m pip install -r requirements.txt Run the example to see it working: python src/demo.py The imports In your code file, import the sys lib, import PySide to have access to all widgets, import PySideX to build the CSD window and finally configure the snake_case feature. As already mentioned, the project uses the snake_case feature to obtain idiomatic code. import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case The minimal example A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: A more complete minimal example In this example, we will add the 'os' library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Quick start"},{"location":"quick_start/#quick-start","text":"We will start by downloading the project and configuring the environment.","title":"Quick start"},{"location":"quick_start/#download-and-configure","text":"Download and enter the project directory: git clone https://github.com/reticulardev/pysidex.git && cd pysidex/ Configure your virtual environment: python3 -m venv venv && . venv/bin/activate Update pip and install dependencies: python -m pip install --upgrade pip && python -m pip install -r requirements.txt Run the example to see it working: python src/demo.py","title":"Download and configure"},{"location":"quick_start/#the-imports","text":"In your code file, import the sys lib, import PySide to have access to all widgets, import PySideX to build the CSD window and finally configure the snake_case feature. As already mentioned, the project uses the snake_case feature to obtain idiomatic code. import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case","title":"The imports"},{"location":"quick_start/#the-minimal-example","text":"A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result:","title":"The minimal example"},{"location":"quick_start/#a-more-complete-minimal-example","text":"In this example, we will add the 'os' library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"A more complete minimal example"},{"location":"reference_PlatformSettings/","text":"PlatformSettings","title":"PlatformSettings"},{"location":"reference_PlatformSettings/#platformsettings","text":"","title":"PlatformSettings"},{"location":"reference_QApplicationWindow/","text":"QApplicationWindow Inherits from QMainWindow Overview The main window of an application. It was built under QMainWindow and some modifications were made to achieve the CSD feature. Class signature QApplicationWindow(is_decorated: bool = False, platform: bool = True) Parameters is_decorated : Type bool , default is False Use False if it is an undecorated CSD window and True if it is server-side decorated. platform : Type bool , default is True The default is True , which is used to follow the user's platform style. These are the control button styles, color and shape of the window borders. Setting False will make the window use an alternative default style. Class methods Only new ones. See the QMainWindow documentation for more. central_widget is_decorated platform_settings reset_style central_widget Signature: central_widget() -> QWidget A pre-configured QWidget . Is a central part of the QApplicationWindow . The main layout of your application must be added to it. self.layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.layout) is_decorated Signature: is_decorated() -> bool Returns False if it is an undecorated CSD window and True if it is server-side decorated. platform_settings Signature: platform_settings() -> PlatformSettings A PlatformSettings object that brings information from the user's platform that is relevant to the composition of the window. reset_style Signature: reset_style() -> None Changes the window style back to the default. Changes A pre-configured central widget already exists and is a central part of the QApplicationWindow . You will get it for use through the central_widget method. The set_object_name method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name \"QApplicationWindow{...}\". The event_filter method needed, at least temporarily, to be rewritten and is therefore not currently accessible. So consider using specific event methods like enter_event and leave_vent . Examples A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: A more complete minimal example In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result: Using all concepts We created the following example to use all the practical concepts in this window, such as using specific event methods instead of event_filter , and also using the \"QApplicationWindow\" id for QSS style . #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"QApplicationWindow"},{"location":"reference_QApplicationWindow/#qapplicationwindow","text":"Inherits from QMainWindow","title":"QApplicationWindow"},{"location":"reference_QApplicationWindow/#overview","text":"The main window of an application. It was built under QMainWindow and some modifications were made to achieve the CSD feature.","title":"Overview"},{"location":"reference_QApplicationWindow/#class-signature","text":"QApplicationWindow(is_decorated: bool = False, platform: bool = True)","title":"Class signature"},{"location":"reference_QApplicationWindow/#parameters","text":"is_decorated : Type bool , default is False Use False if it is an undecorated CSD window and True if it is server-side decorated. platform : Type bool , default is True The default is True , which is used to follow the user's platform style. These are the control button styles, color and shape of the window borders. Setting False will make the window use an alternative default style.","title":"Parameters"},{"location":"reference_QApplicationWindow/#class-methods","text":"Only new ones. See the QMainWindow documentation for more. central_widget is_decorated platform_settings reset_style","title":"Class methods"},{"location":"reference_QApplicationWindow/#central_widget","text":"Signature: central_widget() -> QWidget A pre-configured QWidget . Is a central part of the QApplicationWindow . The main layout of your application must be added to it. self.layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.layout)","title":"central_widget"},{"location":"reference_QApplicationWindow/#is_decorated","text":"Signature: is_decorated() -> bool Returns False if it is an undecorated CSD window and True if it is server-side decorated.","title":"is_decorated"},{"location":"reference_QApplicationWindow/#platform_settings","text":"Signature: platform_settings() -> PlatformSettings A PlatformSettings object that brings information from the user's platform that is relevant to the composition of the window.","title":"platform_settings"},{"location":"reference_QApplicationWindow/#reset_style","text":"Signature: reset_style() -> None Changes the window style back to the default.","title":"reset_style"},{"location":"reference_QApplicationWindow/#changes","text":"A pre-configured central widget already exists and is a central part of the QApplicationWindow . You will get it for use through the central_widget method. The set_object_name method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name \"QApplicationWindow{...}\". The event_filter method needed, at least temporarily, to be rewritten and is therefore not currently accessible. So consider using specific event methods like enter_event and leave_vent .","title":"Changes"},{"location":"reference_QApplicationWindow/#examples","text":"A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result:","title":"Examples"},{"location":"reference_QApplicationWindow/#a-more-complete-minimal-example","text":"In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"A more complete minimal example"},{"location":"reference_QApplicationWindow/#using-all-concepts","text":"We created the following example to use all the practical concepts in this window, such as using specific event methods instead of event_filter , and also using the \"QApplicationWindow\" id for QSS style . #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Using all concepts"},{"location":"reference_QControlButton/","text":"QControlButton","title":"QControlButton"},{"location":"reference_QControlButton/#qcontrolbutton","text":"","title":"QControlButton"},{"location":"reference_QHeaderBar/","text":"QHeaderBar Inherits from QFrame Overview The main control area of an application window, where there are close, maximize and minimize buttons, along with a movement area and the application icon. It's a regular widget and can be aligned wherever you want, not just at the top of the window, but also in other places like the middle or bottom if you're a psychopath. Class signature QHeaderBar(main_window: QApplicationWindow[QtWidgets, QMainWindow]) Parameters main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.headerbar = QHeaderBar(self) Class methods Only new ones. See the QFrame documentation for more. add_widget_to_left add_widget_to_right lef_layout right_layout set_left_control_buttons_visible set_right_control_buttons_visible set_text text add_widget_to_left Signature: add_widget_to_left(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the left side of the header bar (after the control buttons or window icon). add_widget_to_right Signature: add_widget_to_right(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the right side of the header bar (before the control buttons or window icon). lef_layout Signature: lef_layout() -> QHBoxLayout Gets the left layout of the header bar. It is the layout where widgets are added when using the add_widget_to_left method. right_layout Signature: right_layout() -> QHBoxLayout Gets the right layout of the header bar. It is the layout where widgets are added when using the add_widget_to_right method. set_left_control_buttons_visible Signature: set_left_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the left side of the window. Setting this to False will hide them, and True will show them. set_right_control_buttons_visible Signature: set_right_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the right side of the window. Setting this to False will hide them, and True will show them. set_text Signature: set_text(text: str) -> None Parameter text : str Add text in the middle of the header bar. This is typically the text used as the window title. text Signature: text() -> str Gets the text of the header bar. This is the text in the middle, normally used as the window title. Changes The resize_event method needed, at least temporarily, to be rewritten and is therefore not currently accessible. So consider using specific event methods like event_filter . Examples Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) A more complete minimal example In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. SRC_DIR = os.path.dirname(os.path.abspath(__file__)) ... icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. self.set_window_title('App title') self.headerbar.set_text(self.window_title()) We also added a search button on the left side and a menu button on the right side of the header bar # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) This is the result: # !/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) # Window size self.set_minimum_width(300) self.set_minimum_height(200) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec())","title":"QHeaderBar"},{"location":"reference_QHeaderBar/#qheaderbar","text":"Inherits from QFrame","title":"QHeaderBar"},{"location":"reference_QHeaderBar/#overview","text":"The main control area of an application window, where there are close, maximize and minimize buttons, along with a movement area and the application icon. It's a regular widget and can be aligned wherever you want, not just at the top of the window, but also in other places like the middle or bottom if you're a psychopath.","title":"Overview"},{"location":"reference_QHeaderBar/#class-signature","text":"QHeaderBar(main_window: QApplicationWindow[QtWidgets, QMainWindow])","title":"Class signature"},{"location":"reference_QHeaderBar/#parameters","text":"main_window : Type QApplicationWindow (QtWidgets.QMainWindow) Just pass self which indicates the top-level window instance: self.headerbar = QHeaderBar(self)","title":"Parameters"},{"location":"reference_QHeaderBar/#class-methods","text":"Only new ones. See the QFrame documentation for more. add_widget_to_left add_widget_to_right lef_layout right_layout set_left_control_buttons_visible set_right_control_buttons_visible set_text text","title":"Class methods"},{"location":"reference_QHeaderBar/#add_widget_to_left","text":"Signature: add_widget_to_left(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the left side of the header bar (after the control buttons or window icon).","title":"add_widget_to_left"},{"location":"reference_QHeaderBar/#add_widget_to_right","text":"Signature: add_widget_to_right(widget: QWidget) -> None Parameter widget : QWidget Adds a widget to the right side of the header bar (before the control buttons or window icon).","title":"add_widget_to_right"},{"location":"reference_QHeaderBar/#lef_layout","text":"Signature: lef_layout() -> QHBoxLayout Gets the left layout of the header bar. It is the layout where widgets are added when using the add_widget_to_left method.","title":"lef_layout"},{"location":"reference_QHeaderBar/#right_layout","text":"Signature: right_layout() -> QHBoxLayout Gets the right layout of the header bar. It is the layout where widgets are added when using the add_widget_to_right method.","title":"right_layout"},{"location":"reference_QHeaderBar/#set_left_control_buttons_visible","text":"Signature: set_left_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the left side of the window. Setting this to False will hide them, and True will show them.","title":"set_left_control_buttons_visible"},{"location":"reference_QHeaderBar/#set_right_control_buttons_visible","text":"Signature: set_right_control_buttons_visible(visible: bool) -> None Parameter visible : bool Controls the visibility of the control buttons on the right side of the window. Setting this to False will hide them, and True will show them.","title":"set_right_control_buttons_visible"},{"location":"reference_QHeaderBar/#set_text","text":"Signature: set_text(text: str) -> None Parameter text : str Add text in the middle of the header bar. This is typically the text used as the window title.","title":"set_text"},{"location":"reference_QHeaderBar/#text","text":"Signature: text() -> str Gets the text of the header bar. This is the text in the middle, normally used as the window title.","title":"text"},{"location":"reference_QHeaderBar/#changes","text":"The resize_event method needed, at least temporarily, to be rewritten and is therefore not currently accessible. So consider using specific event methods like event_filter .","title":"Changes"},{"location":"reference_QHeaderBar/#examples","text":"Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec())","title":"Examples"},{"location":"reference_QHeaderBar/#a-more-complete-minimal-example","text":"In this example, we will add the os library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. SRC_DIR = os.path.dirname(os.path.abspath(__file__)) ... icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. self.set_window_title('App title') self.headerbar.set_text(self.window_title()) We also added a search button on the left side and a menu button on the right side of the header bar # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) This is the result: # !/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) # Search button self.search_button = QtWidgets.QToolButton() self.search_button.set_icon(QtGui.QIcon.from_theme('search')) self.headerbar.add_widget_to_left(self.search_button) # Menu button self.menu_button = QtWidgets.QToolButton() self.menu_button.set_icon(QtGui.QIcon.from_theme('application-menu')) self.headerbar.add_widget_to_right(self.menu_button) # Window size self.set_minimum_width(300) self.set_minimum_height(200) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec())","title":"A more complete minimal example"},{"location":"reference_QWindowControlButtons/","text":"QWindowControlButtons","title":"QWindowControlButtons"},{"location":"reference_QWindowControlButtons/#qwindowcontrolbuttons","text":"","title":"QWindowControlButtons"},{"location":"reference_QWindowMoveArea/","text":"QWindowMoveArea","title":"QWindowMoveArea"},{"location":"reference_QWindowMoveArea/#qwindowmovearea","text":"","title":"QWindowMoveArea"},{"location":"styling/","text":"Styling The setObjectName method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name. self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') The remaining widgets remain unchanged. See the PySide documentation for more. Example #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Styling"},{"location":"styling/#styling","text":"The setObjectName method does not work for the QApplicationWindow nor for its central widget . To change the QSS style you need to use the base name. self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') The remaining widgets remain unchanged. See the PySide documentation for more.","title":"Styling"},{"location":"styling/#example","text":"#!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) def enter_event(self, event: QtGui.QEnterEvent) -> None: self.set_attribute(QtCore.Qt.WA_TranslucentBackground) self.set_style_sheet( 'QApplicationWindow {' ' background-color: rgba(65, 50, 75, 0.8);' ' border-radius: 10px;' ' border: 1px solid #555;}') def leave_event(self, event: QtGui.QEnterEvent) -> None: self.reset_style() if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Example"},{"location":"tests/","text":"Tests Download the Git repository and with the terminal enter the project directory. unittest Standard library unit tests can be run as follows python3 -m unittest discover coverage Test coverage can be verified using the \"coverage\" lib. Use pip to install it. pip3 install --upgrade pip pip3 install coverage Then run the unit tests using the \"coverage\" command and then use the \"report\" argument to get the test coverage status. coverage run -m unittest discover coverage report -m","title":"Tests"},{"location":"tests/#tests","text":"Download the Git repository and with the terminal enter the project directory.","title":"Tests"},{"location":"tests/#unittest","text":"Standard library unit tests can be run as follows python3 -m unittest discover","title":"unittest"},{"location":"tests/#coverage","text":"Test coverage can be verified using the \"coverage\" lib. Use pip to install it. pip3 install --upgrade pip pip3 install coverage Then run the unit tests using the \"coverage\" command and then use the \"report\" argument to get the test coverage status. coverage run -m unittest discover coverage report -m","title":"coverage"}]}