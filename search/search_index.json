{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"PySideX PySide eXtras is a collection of extra resources for pyside with a focus on CSD ( Client-side decoration ). It is the basis of the ( MPX ) project. Conforms to the list of objectives specified in the \" Client-Side Decorations Initiative \" of the Gnome project. QApplicationWindow : A CSD (Client-side decoration) window without server-side decoration (SSD). It is resizable in all corners and has a shadow (optional). QControlButton : A Window control button. It could be the \"close\", \"minimize\" or \"maximize\" button. QWindowControlButtons : The buttons to \"close\", \"maximize\" and \"minimize\" the window. QWindowMoveArea : An area to drag the window. It is also possible to maximize and demaximize the window by double-clicking. QHeaderBar : A ready-made header bar, with drag area (QWindowMoveArea), control buttons (QWindowControlButtons), the window icon and methods for adding widgets to its right and left. When possible, the control buttons respect the positioning settings, the global menu and the system theme. They also behave desirably when the window is full screen. *The theme is still the PySide default","title":"Home"},{"location":"#pysidex","text":"PySide eXtras is a collection of extra resources for pyside with a focus on CSD ( Client-side decoration ). It is the basis of the ( MPX ) project. Conforms to the list of objectives specified in the \" Client-Side Decorations Initiative \" of the Gnome project. QApplicationWindow : A CSD (Client-side decoration) window without server-side decoration (SSD). It is resizable in all corners and has a shadow (optional). QControlButton : A Window control button. It could be the \"close\", \"minimize\" or \"maximize\" button. QWindowControlButtons : The buttons to \"close\", \"maximize\" and \"minimize\" the window. QWindowMoveArea : An area to drag the window. It is also possible to maximize and demaximize the window by double-clicking. QHeaderBar : A ready-made header bar, with drag area (QWindowMoveArea), control buttons (QWindowControlButtons), the window icon and methods for adding widgets to its right and left. When possible, the control buttons respect the positioning settings, the global menu and the system theme. They also behave desirably when the window is full screen. *The theme is still the PySide default","title":"PySideX"},{"location":"about/","text":"About Sources: https://github.com/reticulardev/pysidex","title":"About"},{"location":"about/#about","text":"Sources: https://github.com/reticulardev/pysidex","title":"About"},{"location":"overview/","text":"Overview This is a work that uses Qt's Python bind to build a window with its own decoration (CSD), which eliminates the decoration of the operating system's window server (SSD). Qt is an old and mature lib, but it was not originally designed to provide CSD support. Although it has added initial native support to CSD in recent years, it is still an incomplete work. Therefore, the PySideX and MPX projects are CSD implementations usable within the limits of Qt. So some hacks were made so that it was possible to have a usable window with desirable features such as a headerbar, customization of window borders, window control buttons with native platform integration, window resizing and movement. Targets There are necessary and some desirable goals to be met, and as a parameter, we use the \" Client-Side Decorations Initiative \" of the Gnome project as a necessary goal to be met. This initiative contains a list of reasonable goals to achieve: No title bar Native-looking close/maximize/minimize icons Respect the setting for showing/hiding minimize and maximize Respect the setting for buttons to be on the left/right side of the window Provide native system context menu on right click Limitations and mitigations Desirable goals to be achieved are part of some limitations. Some of the Qt Company's difficulties in supporting CSD were addressed in article \" Custom client-side window decorations in Qt 5.15 \" on group blog. One of the details that has not yet been resolved is maintaining the window shadow when using the 'FramelessWindowHint' flag, which removes the server-side decorations. We could request 1 edge pixel from the window server, but this would prevent us from customizing the corners in a satisfactory way. When remembering that customizing the edges is the biggest gain in CSD, messing it up would destroy the most significant part of the project. Therefore, we chose to provide a non-native shadow using Qt effects, which can be easily manipulated or removed, and also easy to change when an update to this feature becomes available. Another particularity to be resolved is the menu bar. As it is not rendered properly in the translucent part of the QMainWindow, which is modified to adapt the borders, it loses integration with global menus. The interesting thing here is that the CSD was designed for \"UX/UI design\" which does not match menu bars, as many have already observed. The reason for this, is because they are very large and disorganized. In modern programs they are already disabled, or sometimes with access shortcut. An alternative UX design approach is recommended in this case. Another inconvenience is windows with a blurred background. It's not impossible or very complicated to blur the background of the QMainWindow, but we had some pertinent problems with the window mask. It is not always able to remove the effect outside the rounded edges, leaving those little points slightly visible. Believe me, even those who don't have \"OCD\" start to acquire it after looking at it for a while. Therefore, as providing windows with blurred backgrounds by default is not a priority, this has temporarily fallen out of the plans. Maintainability The extra widgets are designed to be limited to the minimum possible, just to provide a CSD Window. This means that all graphics library support officially remains with the Qt Company. This decision makes the project small and gives us the chance to keep it actively updated with the latest stable versions of Pyside. It also provides the security of being able to continue officially using the robust original Qt. Code style Qt originally uses the camelCase code style and this is reflected in PySide which also uses it by default. In an effort to make Python code idiomatic, the snake_case and true_property features were introduced. Find out more about the feature in the official Pyside documentation In our tests, the true_property feature didn't work well in every way, but the snake_case style was maintained. Anyone who has worked with PyGObject, the GTK bind to Python, will feel right at home. This is a project based on QtWidgets and for now there are no plans to support QML. Conclusion As Qt Company progresses with CSD support, this project will be improved. And fortunately, it is now possible to obtain a usable and satisfactory result. The Widgets that were created are very flexible and easy to implement.","title":"Project overview"},{"location":"overview/#overview","text":"This is a work that uses Qt's Python bind to build a window with its own decoration (CSD), which eliminates the decoration of the operating system's window server (SSD). Qt is an old and mature lib, but it was not originally designed to provide CSD support. Although it has added initial native support to CSD in recent years, it is still an incomplete work. Therefore, the PySideX and MPX projects are CSD implementations usable within the limits of Qt. So some hacks were made so that it was possible to have a usable window with desirable features such as a headerbar, customization of window borders, window control buttons with native platform integration, window resizing and movement.","title":"Overview"},{"location":"overview/#targets","text":"There are necessary and some desirable goals to be met, and as a parameter, we use the \" Client-Side Decorations Initiative \" of the Gnome project as a necessary goal to be met. This initiative contains a list of reasonable goals to achieve: No title bar Native-looking close/maximize/minimize icons Respect the setting for showing/hiding minimize and maximize Respect the setting for buttons to be on the left/right side of the window Provide native system context menu on right click","title":"Targets"},{"location":"overview/#limitations-and-mitigations","text":"Desirable goals to be achieved are part of some limitations. Some of the Qt Company's difficulties in supporting CSD were addressed in article \" Custom client-side window decorations in Qt 5.15 \" on group blog. One of the details that has not yet been resolved is maintaining the window shadow when using the 'FramelessWindowHint' flag, which removes the server-side decorations. We could request 1 edge pixel from the window server, but this would prevent us from customizing the corners in a satisfactory way. When remembering that customizing the edges is the biggest gain in CSD, messing it up would destroy the most significant part of the project. Therefore, we chose to provide a non-native shadow using Qt effects, which can be easily manipulated or removed, and also easy to change when an update to this feature becomes available. Another particularity to be resolved is the menu bar. As it is not rendered properly in the translucent part of the QMainWindow, which is modified to adapt the borders, it loses integration with global menus. The interesting thing here is that the CSD was designed for \"UX/UI design\" which does not match menu bars, as many have already observed. The reason for this, is because they are very large and disorganized. In modern programs they are already disabled, or sometimes with access shortcut. An alternative UX design approach is recommended in this case. Another inconvenience is windows with a blurred background. It's not impossible or very complicated to blur the background of the QMainWindow, but we had some pertinent problems with the window mask. It is not always able to remove the effect outside the rounded edges, leaving those little points slightly visible. Believe me, even those who don't have \"OCD\" start to acquire it after looking at it for a while. Therefore, as providing windows with blurred backgrounds by default is not a priority, this has temporarily fallen out of the plans.","title":"Limitations and mitigations"},{"location":"overview/#maintainability","text":"The extra widgets are designed to be limited to the minimum possible, just to provide a CSD Window. This means that all graphics library support officially remains with the Qt Company. This decision makes the project small and gives us the chance to keep it actively updated with the latest stable versions of Pyside. It also provides the security of being able to continue officially using the robust original Qt.","title":"Maintainability"},{"location":"overview/#code-style","text":"Qt originally uses the camelCase code style and this is reflected in PySide which also uses it by default. In an effort to make Python code idiomatic, the snake_case and true_property features were introduced. Find out more about the feature in the official Pyside documentation In our tests, the true_property feature didn't work well in every way, but the snake_case style was maintained. Anyone who has worked with PyGObject, the GTK bind to Python, will feel right at home. This is a project based on QtWidgets and for now there are no plans to support QML.","title":"Code style"},{"location":"overview/#conclusion","text":"As Qt Company progresses with CSD support, this project will be improved. And fortunately, it is now possible to obtain a usable and satisfactory result. The Widgets that were created are very flexible and easy to implement.","title":"Conclusion"},{"location":"quick_start/","text":"Quick start We will start by downloading the project and configuring the environment. Download and configure Download and enter the project directory: git clone https://github.com/reticulardev/pysidex.git && cd pysidex/ Configure your virtual environment: python3 -m venv venv && . venv/bin/activate Update pip and install dependencies: python -m pip install --upgrade pip && python -m pip install -r requirements.txt Run the example to see it working: python src/demo.py The imports In your code file, import the sys lib, import PySide to have access to all widgets, import PySideX to build the CSD window and finally configure the snake_case feature. As already mentioned, the project uses the snake_case feature to obtain idiomatic code. import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case The minimal example A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result: A more complete minimal example In this example, we will add the 'os' library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"Quick start"},{"location":"quick_start/#quick-start","text":"We will start by downloading the project and configuring the environment.","title":"Quick start"},{"location":"quick_start/#download-and-configure","text":"Download and enter the project directory: git clone https://github.com/reticulardev/pysidex.git && cd pysidex/ Configure your virtual environment: python3 -m venv venv && . venv/bin/activate Update pip and install dependencies: python -m pip install --upgrade pip && python -m pip install -r requirements.txt Run the example to see it working: python src/demo.py","title":"Download and configure"},{"location":"quick_start/#the-imports","text":"In your code file, import the sys lib, import PySide to have access to all widgets, import PySideX to build the CSD window and finally configure the snake_case feature. As already mentioned, the project uses the snake_case feature to obtain idiomatic code. import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case","title":"The imports"},{"location":"quick_start/#the-minimal-example","text":"A highly discouraged minimal example would be: app = QtWidgets.QApplication(sys.argv) window = QtWidgetsX.QApplicationWindow() window.show() sys.exit(app.exec()) This would give you a little window that can be resized in any direction. However, there is no button to close the application and, depending on your platform, it may be difficult to close the application: A better minimal example in this situation includes adding a headerbar to access the window control buttons: class Window(QtWidgetsX.QApplicationWindow): def __init__(self): super().__init__() self.main_layout = QtWidgets.QVBoxLayout() self.central_widget().set_layout(self.main_layout) self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) Note that a central widget with appropriate settings already exists. As it is already accessed directly, there is no need to create one. self.central_widget().set_layout(self.main_layout) Also note that the headerbar widget is independent, meaning you can place it wherever you want, which is why we aligned it at the top. self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) This is the result:","title":"The minimal example"},{"location":"quick_start/#a-more-complete-minimal-example","text":"In this example, we will add the 'os' library to add an icon with a dynamic path. The icon, once configured in the window, will be automatically recognized by the header bar. The title is not automatically recognized by the header bar as in the case of the icon, because not in all use cases a window needs to have the title displayed. In our case, if we want to see the window title, we need to manually redirect it to the header bar. #!/usr/bin/env python3 import os import sys from PySide6 import QtCore, QtGui, QtWidgets from PySideX import QtWidgetsX from __feature__ import snake_case SRC_DIR = os.path.dirname(os.path.abspath(__file__)) sys.path.append(SRC_DIR) class Window(QtWidgetsX.QApplicationWindow): def __init__(self, *args, **kwargs) -> None: super().__init__(*args, **kwargs) # Window icon icon_path = os.path.join(SRC_DIR, 'icon.svg') window_icon = QtGui.QIcon(QtGui.QPixmap(icon_path)) self.set_window_icon(window_icon) # Layout self.main_layout = QtWidgets.QVBoxLayout() self.main_layout.set_contents_margins(0, 0, 0, 0) self.main_layout.set_alignment(QtCore.Qt.AlignTop) self.central_widget().set_layout(self.main_layout) # Headerbar self.headerbar = QtWidgetsX.QHeaderBar(self) self.main_layout.add_widget(self.headerbar) # Window title self.set_window_title('App title') self.headerbar.set_text(self.window_title()) if __name__ == '__main__': app = QtWidgets.QApplication(sys.argv) window = Window() window.show() sys.exit(app.exec()) This is the result:","title":"A more complete minimal example"},{"location":"reference_QApplicationWindow/","text":"QApplicationWindow","title":"QApplicationWindow"},{"location":"reference_QApplicationWindow/#qapplicationwindow","text":"","title":"QApplicationWindow"},{"location":"reference_QControlButton/","text":"QControlButton","title":"QControlButton"},{"location":"reference_QControlButton/#qcontrolbutton","text":"","title":"QControlButton"},{"location":"reference_QHeaderBar/","text":"QHeaderBar","title":"QHeaderBar"},{"location":"reference_QHeaderBar/#qheaderbar","text":"","title":"QHeaderBar"},{"location":"reference_QWindowControlButtons/","text":"QWindowControlButtons","title":"QWindowControlButtons"},{"location":"reference_QWindowControlButtons/#qwindowcontrolbuttons","text":"","title":"QWindowControlButtons"},{"location":"reference_QWindowMoveArea/","text":"QWindowMoveArea","title":"QWindowMoveArea"},{"location":"reference_QWindowMoveArea/#qwindowmovearea","text":"","title":"QWindowMoveArea"},{"location":"tests/","text":"Tests Download the Git repository and with the terminal enter the project directory. unittest Standard library unit tests can be run as follows python3 -m unittest discover coverage Test coverage can be verified using the \"coverage\" lib. Use pip to install it. pip3 install --upgrade pip pip3 install coverage Then run the unit tests using the \"coverage\" command and then use the \"report\" argument to get the test coverage status. coverage run -m unittest discover coverage report -m","title":"Tests"},{"location":"tests/#tests","text":"Download the Git repository and with the terminal enter the project directory.","title":"Tests"},{"location":"tests/#unittest","text":"Standard library unit tests can be run as follows python3 -m unittest discover","title":"unittest"},{"location":"tests/#coverage","text":"Test coverage can be verified using the \"coverage\" lib. Use pip to install it. pip3 install --upgrade pip pip3 install coverage Then run the unit tests using the \"coverage\" command and then use the \"report\" argument to get the test coverage status. coverage run -m unittest discover coverage report -m","title":"coverage"}]}